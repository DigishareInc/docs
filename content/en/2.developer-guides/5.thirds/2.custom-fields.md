---
title: Custom Fields Management
description: Comprehensive guide to extending Digishare entities with custom metadata, including schema definition, high-performance indexing, and advanced filtering.
icon: i-lucide-tags
---

Extend your contacts (Thirds) and other entities with custom data structures tailored to your business logic. Digishare supports dynamic metadata indexing, allowing you to store, type-check, and filter custom properties on the fly.

We offer two approaches depending on your specific requirements: a schema-less Quick Approach, and a strictly typed Advanced API Approach.

---

## Architectural Approaches

::card-group
::card{title="Quick Fields (Schema-less)" icon="i-lucide-zap"}
Store key-value pairs directly in the entity's `data.custom_fields` generic JSON object. Fields are automatically inferred, synchronized, and implicitly indexed by the Custom Fields system upon entity creation or update. Best for unstructured or rapidly changing metadata.
::

::card{title="Advanced API (Strict Schema)" icon="i-lucide-database"}
Explicitly define data schemas using the dedicated Custom Field Definitions API. This allows you to enforce strict data typing (`string`, `float`, `date`, `bool`, etc.), define enum `options`, and securely namespace fields into `groups`. Best for analytics, systematic integrations, and complex filtering.
::
::

---

## The Quick Approach: `data.custom_fields`

Store custom data implicitly during standard entity operations. Digishare's background processes will automatically detect new keys, create implicit schema definitions scoped to your company, and index the values for high-performance querying.

### 1. Create During Entity Creation

Provide the `data.custom_fields` object when creating a Contact (Third).

::api-playground{method="POST" url="<https://api.digishare.ma/v1/thirds>" description="Create a contact with implicit custom fields." :variables='{"token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}", "Content-Type": "application/json"}' :body='{"first_name": "John", "last_name": "Doe", "data": {"custom_fields": {"balance": 150.75, "loyalty_tier": "gold", "is_vip": true}}}'}
::

### 2. Update Existing Entity Fields

Patch the entity's data payload to merge new fields or overwrite existing custom fields.

::api-playground{method="PATCH" url="<https://api.digishare.ma/v1/thirds/{id}>" description="Merge or update custom fields." :variables='{"id": "THIRD_ID", "token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}", "Content-Type": "application/json"}' :body='{"data": {"custom_fields": {"balance": 200.00, "last_purchase": "2026-01-18"}}}'}
::

---

## The Advanced Approach: Explicit Schemas

For enterprise-grade implementations, you can explicitly define the schema and properties of your custom fields before injecting data. This approach enforces type safety and prevents disparate data proliferation.

### 1. Define or Manage Field Schemas

Use the definitions API to dictate how custom fields should be processed. Field definitions are automatically scoped and secured to your authenticated company context.

**Properties:**

- `key` (string): The unique identifier for the field (e.g., `account_balance`).
- `label` (string): Human-readable name (e.g., `Account Balance`).
- `type` (string): The data type (see supported types below).
- `group` (string, optional): Logical grouping (default: `default`).
- `model_type` (string, optional): The entity this field belongs to (default: `Third`).
- `options` (array, optional): Allowed scalar values for enum types.

::api-playground{method="POST" url="<https://api.digishare.ma/v1/custom-field-definitions>" description="Define a strict custom field schema." :variables='{"token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}", "Content-Type": "application/json"}' :body='{"key": "loyalty_program", "label": "Loyalty Program", "type": "string", "group": "marketing", "model_type": "Third", "options": ["None", "Silver", "Gold", "Platinum"]}'}
::

**Retrieve Existing Definitions:**

::api-playground{method="GET" url="<https://api.digishare.ma/v1/custom-field-definitions>" description="List explicit custom field definitions scoped to your company." :variables='{"token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}"}'}
::

#### Supported Data Types

| Type     | Internal Storage | Auto-Casting Behavior                   |
| -------- | ---------------- | --------------------------------------- |
| `string` | Indexed Text     | Stored as is                            |
| `int`    | Native Integer   | Formatted to int                        |
| `float`  | Integer (x1000)  | Formatted to float                      |
| `bool`   | Boolean / Bit    | `1/0`, `true/false`, `yes/no`           |
| `date`   | Integer (`Ymd`)  | Parses ISO `YYYY-MM-DD` or `DD/MM/YYYY` |

### 2. Mutate Entity Custom Fields Directly

Instead of patching the entire Third, target the custom fields directly via the dedicated endpoint.

::api-playground{method="POST" url="<https://api.digishare.ma/v1/thirds/{id}/custom-fields>" description="Set custom field values directly." :variables='{"id": "THIRD_ID", "token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}", "Content-Type": "application/json"}' :body='{"fields": {"balance": 150.75, "order_count": 12}, "group": "billing"}'}
::

### 3. Retrieve Entity Custom Fields

Retrieve all attached custom fields, independently of the parent entity representation.

::api-playground{method="GET" url="<https://api.digishare.ma/v1/thirds/{id}/custom-fields>" description="Get customized metadata for contact." :variables='{"id": "THIRD_ID", "token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}"}'}
::

### 4. Remove Specific Fields

Erase specific custom keys from the entity's data store.

::api-playground{method="DELETE" url="<https://api.digishare.ma/v1/thirds/{id}/custom-fields>" description="Nullify specific custom fields." :variables='{"id": "THIRD_ID", "token": "YOUR_ACCESS_TOKEN"}' :headers='{"Authorization": "Bearer {token}", "Content-Type": "application/json"}' :body='{"keys": ["balance", "order_count"]}'}
::

---

## Advanced Indexing & Filtering

Digishare indexes custom fields out of the box, offering powerful dynamic queries capable of performing range and relational lookups across your dataset.

### Filter Queries By Custom Fields

Find entities intersecting with metadata constraints. Standard operators scale effectively on `int`, `float`, and `date` types.

```bash
# Get contacts exceeding a specific balance
GET /v1/thirds?custom_filters={"balance":{"operator":">","value":100}}

# Get contacts onboarded after a specific timeline
GET /v1/thirds?custom_filters={"last_purchase":{"operator":">=","value":"2026-01-01"}}

# Get VIP contacts where boolean is exactly true
GET /v1/thirds?custom_filters={"is_vip":{"operator":"=","value":true}}
```

#### Operator Reference

| Operator | Comparison |
| -------- | ---------- |
| `=`      | Equals (Implicit Default) |
| `>`      | Strictly Greater than |
| `<`      | Strictly Less than |
| `>=`     | Greater or Equal |
| `<=`     | Less or Equal |
| `!=`     | Not Equal |

---

## Spreadsheet / Bulk Imports

When importing bulk data (e.g., CSV / Excel files), Digishare parses dynamic columns effortlessly. Append the `cf_` or `custom_` prefix to your file columns, and the engine will natively import and bind them as custom fields to the respective entities.

| first_name | email            | cf_balance | cf_loyalty_tier | cf_is_vip |
| ---------- | ---------------- | ---------- | --------------- | --------- |
| John       | <john@example.com> | 150.75     | gold            | true      |
| Jane       | <jane@example.com> | 50.00      | silver          | false     |

---

## Strategy Comparison Matrix

Determine the best strategy based on system prerequisites:

| Requirement / Use Case | Quick Fields | Advanced API |
| ---------------------- | ------------ | ------------ |
| Rapid Prototyping      | ✅ Best      | Supported    |
| Single Query Execution | ✅ Yes       | Multi-request|
| Enum Restrictions      | ❌ No        | ✅ Yes       |
| Explicit Type Safety   | ❌ Inferred  | ✅ Yes       |
| Schema Governance      | ❌ Freeform  | ✅ Yes       |
| Indexed Lookup         | ✅ Auto-sync | ✅ Native    |
